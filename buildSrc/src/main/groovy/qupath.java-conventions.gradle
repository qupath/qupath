/**
 * Define jar manifests and the toolchain JDK.
 * This separates the JDK used to run Gradle from that used to build QuPath.
 */

plugins {
    id 'java'
    id 'maven-publish'
}

java {
    def version = project.findProperty('toolchain')
    if (!version)
        version = 17
    else if (version.strip() == 'skip')
        version = null
    if (version != null) {
        logger.info("Setting toolchain to {}", version)
        toolchain {
            languageVersion = JavaLanguageVersion.of(version)
        }
    }
    withSourcesJar()
    withJavadocJar()
}

// Include parameter names, so they are available in the script editor via reflection
compileJava {
    options.compilerArgs << '-parameters'
}

// Avoid 'Entry .gitkeep is a duplicate but no duplicate handling strategy has been set.'
// when using withSourcesJar()
tasks.withType(org.gradle.jvm.tasks.Jar) {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

afterEvaluate {

    // Including the latest commit when building can help traceability - but requires git being available
    // TODO: Don't compute this separately for separate libraries
    ext {
        latestGitCommit = null
    }
    def requestLatestCommit = project.findProperty('git-commit') == 'true'
    if (requestLatestCommit) {
        try {
            def stdout = new ByteArrayOutputStream()
            def result = exec {
                commandLine 'git', 'log', "--pretty=format:'%h'", "-n 1"
                standardOutput = stdout
            }
            latestGitCommit = stdout.toString().trim()
//            logger.info('Latest commit: {}', latestGitCommit)
        } catch (Exception e) {
            logger.warn('Unable to get latest commit: ' + e.getLocalizedMessage())
            latestGitCommit = 'Unknown (is Git installed?)'
        }
    } else {
        logger.info("I won't try to get the last commit - consider running with '-Pgit-commit=true' if you want this next time (assuming Git is installed)")
    }

    jar {
        // Important to set version so this can be queried within QuPath
        if (hasProperty('moduleName')) {
            inputs.property("moduleName", moduleName)
            manifest {
                def manifestAttributes = [
                        "Implementation-Vendor" : "QuPath developers",
                        "Implementation-Version": project.version,
                        'Automatic-Module-Name' : "io.github." + moduleName,
                        "QuPath-build-time"     : new Date().format("yyyy-MM-dd, HH:mm")
                ]

                if (latestGitCommit != null)
                    manifestAttributes["QuPath-latest-commit"] = latestGitCommit

                attributes(manifestAttributes)
            }
        }
    }
}


/*
 * Create javadocs for all modules/packages in one place.
 * Use -PstrictJavadoc=true to fail on error with doclint (which is rather strict).
 */
def strictJavadoc = findProperty('strictJavadoc')

tasks.withType(Javadoc).each { javadocTask ->
    if (!strictJavadoc) {
        javadocTask.options.addStringOption('Xdoclint:none', '-quiet')
    }
   javadocTask.options.encoding = 'UTF-8'

    rootProject.tasks.withType(Javadoc) { rootTask ->
        rootTask.source += javadocTask.source
        rootTask.classpath += javadocTask.classpath
        rootTask.excludes += javadocTask.excludes
        rootTask.includes += javadocTask.includes
    }
}

/*
 * On Apple Silicon (at least), there are problems running tests involving JavaCPP 1.5.5 with 
 * java.lang.OutOfMemoryError: Physical memory usage is too high: physicalBytes (1028M) > maxPhysicalBytes (1024M)
 * https://github.com/bytedeco/javacpp/issues/468
 */
test {
    if ("32".equals(System.getProperty("sun.arch.data.model")))
        maxHeapSize = '1G'
    else
        maxHeapSize = '2G'
}

